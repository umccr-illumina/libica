<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>libica.app.dataops API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>libica.app.dataops</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import gzip
import logging
from contextlib import closing
from tempfile import NamedTemporaryFile

import requests

from libica.app import AppHelper
from libica.openapi.v2 import ApiException, ApiClient
from libica.openapi.v2.api.project_data_api import ProjectDataApi
from libica.openapi.v2.model.download import Download
from libica.openapi.v2.model.project_data import ProjectData
from libica.openapi.v2.model.project_data_paged_list import ProjectDataPagedList

logger = logging.getLogger(__name__)


class ProjectDataOps:

    def __init__(self, project_id: str, api_client: ApiClient = None):
        self.project_id: str = project_id

        if api_client:
            self.api_client = api_client
        else:
            # otherwise, we build api_client with standard lookup from well-known locations
            self.api_client: ApiClient = AppHelper().build_icav2_configuration().get_icav2_api_client()

    def check_path(self, file_path: str) -&gt; list:
        &#34;&#34;&#34;Use cases
        This behaves like UNIX `ls` command whereas you can check an absolute path to file or a directory.
        You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
        Otherwise, it returns file(s) found.

        NOTE: This wrap list_files but more strict to raise FileNotFoundError if zero match.

        :param file_path:
        :return: List of ProjectData objects
        :rtype: list[ProjectData]
        &#34;&#34;&#34;

        files = self.list_files(file_path)
        if len(files) == 0:
            raise FileNotFoundError(f&#34;No file(s) found in project {self.project_id} at {file_path}&#34;)
        return files

    def get_file_to_bytes(self, file_path: str) -&gt; bytes:
        &#34;&#34;&#34;
        get_object_to_bytes API, with on-the-fly gzip detection and decompression

        :param file_path:
        :return bytes: bytes from the decompressed File body
        &#34;&#34;&#34;
        try:
            ntf = self.download_file(file_path)
            if file_path.endswith(&#34;.gz&#34;):
                obj_bytes = gzip.decompress(ntf.read())
            else:
                obj_bytes = ntf.read()
            ntf.close()
            return obj_bytes
        except Exception as e:
            message = f&#34;Failed on reading the specified file in project {self.project_id} at {file_path}&#34;
            raise FileNotFoundError(f&#34;{message} Exception: {e}&#34;)

    def list_files(self, file_path=None) -&gt; list:
        &#34;&#34;&#34;Use cases
        Get file listing for given project_id and paths.
        If path are not specified, it will return listing of all files under given project_id.
        Listing is recursive in nature for folder path.
        You can still specify an absolute path for a file.

        :param file_path: default list all
        :return: List of ProjectData objects
        :rtype: list[ProjectData]
        &#34;&#34;&#34;

        if file_path is None:
            file_path = []  # list everything
        elif isinstance(file_path, str):
            file_path = [file_path]  # wrap str into list

        items = []

        with closing(self.api_client) as ctx_api_client:
            project_data_api: ProjectDataApi = ProjectDataApi(api_client=ctx_api_client)

            try:
                page_token = &#34;&#34;
                while True:
                    project_data_paged_list: ProjectDataPagedList = project_data_api.get_project_data_list(
                        project_id=self.project_id,
                        file_path=file_path,
                        page_size=str(1000),
                        page_token=page_token,
                    )

                    items.extend(project_data_paged_list.items)

                    page_token = project_data_paged_list.next_page_token
                    if not project_data_paged_list.next_page_token:
                        break

            except ApiException as e:
                logger.error(e)

        return items

    def download(self, file_id):
        with closing(self.api_client) as ctx_api_client:
            project_data_api: ProjectDataApi = ProjectDataApi(api_client=ctx_api_client)
            dl: Download = project_data_api.create_download_url_for_data(
                project_id=self.project_id,
                data_id=file_id,
            )
            return dl

    def download_by_file_path(self, file_path: str) -&gt; (Download, None):
        logger.info(f&#34;Downloading file from project_id {self.project_id} at {file_path}&#34;)

        file_list = self.list_files(file_path=file_path)

        if not len(file_list) == 1:
            logger.warning(f&#34;Please specify a single file. &#34;
                           f&#34;Found {len(file_list)} files in project_id {self.project_id} at {file_path}&#34;)
            return None

        if len(file_list) == 0:
            logger.warning(f&#34;File not found in in project_id {self.project_id} at {file_path}&#34;)
            return None

        prj_data: ProjectData = file_list[0]

        return self.download(prj_data.data.id)

    def create_presigned_url(self, file_path: str) -&gt; str:
        return self.download_by_file_path(file_path).url

    def download_file(self, file_path: str) -&gt; (NamedTemporaryFile, None):
        &#34;&#34;&#34;Retrieve _single_ Project data file

        It collects matching path (one exact file) through list_files().
        Hence, there should only be one item in the list.
        Then, we use requests library to download the file from presigned URL to temporary storage.
        The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes &#39;out of scope&#39;.

        NOTE:
        If multiple files are found, it warns and return None.

        It is recommended to close NamedTemporaryFile after use.
        For example, work within closing context manager like so.
            with closing(ntf) as f:
                with open(f.name, newline=&#39;&#39;) as csv_file:
                    csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
                    ...
                    ...

        :param file_path: the GDS path of the file to download
        :return NamedTemporaryFile: or None if file is not found or multiple files are found
        &#34;&#34;&#34;
        presigned_url = self.create_presigned_url(file_path)

        req = requests.get(presigned_url)

        ntf = NamedTemporaryFile()
        with open(ntf.name, &#39;wb&#39;) as f:
            f.write(req.content)

        return ntf

    def presign_file(self, file_id: str) -&gt; (bool, str):
        try:
            dl = self.download(file_id)
            return True, dl.url
        except ApiException as e:
            message = f&#34;Failed to sign the specified file {file_id} in project {self.project_id}. Exception - {e}&#34;
            logger.error(message)
            return False, message


class BundleDataOps:
    # TODO
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="libica.app.dataops.BundleDataOps"><code class="flex name class">
<span>class <span class="ident">BundleDataOps</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BundleDataOps:
    # TODO
    pass</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps"><code class="flex name class">
<span>class <span class="ident">ProjectDataOps</span></span>
<span>(</span><span>project_id: str, api_client: <a title="libica.openapi.v2.api_client.ApiClient" href="../openapi/v2/api_client.html#libica.openapi.v2.api_client.ApiClient">ApiClient</a> = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectDataOps:

    def __init__(self, project_id: str, api_client: ApiClient = None):
        self.project_id: str = project_id

        if api_client:
            self.api_client = api_client
        else:
            # otherwise, we build api_client with standard lookup from well-known locations
            self.api_client: ApiClient = AppHelper().build_icav2_configuration().get_icav2_api_client()

    def check_path(self, file_path: str) -&gt; list:
        &#34;&#34;&#34;Use cases
        This behaves like UNIX `ls` command whereas you can check an absolute path to file or a directory.
        You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
        Otherwise, it returns file(s) found.

        NOTE: This wrap list_files but more strict to raise FileNotFoundError if zero match.

        :param file_path:
        :return: List of ProjectData objects
        :rtype: list[ProjectData]
        &#34;&#34;&#34;

        files = self.list_files(file_path)
        if len(files) == 0:
            raise FileNotFoundError(f&#34;No file(s) found in project {self.project_id} at {file_path}&#34;)
        return files

    def get_file_to_bytes(self, file_path: str) -&gt; bytes:
        &#34;&#34;&#34;
        get_object_to_bytes API, with on-the-fly gzip detection and decompression

        :param file_path:
        :return bytes: bytes from the decompressed File body
        &#34;&#34;&#34;
        try:
            ntf = self.download_file(file_path)
            if file_path.endswith(&#34;.gz&#34;):
                obj_bytes = gzip.decompress(ntf.read())
            else:
                obj_bytes = ntf.read()
            ntf.close()
            return obj_bytes
        except Exception as e:
            message = f&#34;Failed on reading the specified file in project {self.project_id} at {file_path}&#34;
            raise FileNotFoundError(f&#34;{message} Exception: {e}&#34;)

    def list_files(self, file_path=None) -&gt; list:
        &#34;&#34;&#34;Use cases
        Get file listing for given project_id and paths.
        If path are not specified, it will return listing of all files under given project_id.
        Listing is recursive in nature for folder path.
        You can still specify an absolute path for a file.

        :param file_path: default list all
        :return: List of ProjectData objects
        :rtype: list[ProjectData]
        &#34;&#34;&#34;

        if file_path is None:
            file_path = []  # list everything
        elif isinstance(file_path, str):
            file_path = [file_path]  # wrap str into list

        items = []

        with closing(self.api_client) as ctx_api_client:
            project_data_api: ProjectDataApi = ProjectDataApi(api_client=ctx_api_client)

            try:
                page_token = &#34;&#34;
                while True:
                    project_data_paged_list: ProjectDataPagedList = project_data_api.get_project_data_list(
                        project_id=self.project_id,
                        file_path=file_path,
                        page_size=str(1000),
                        page_token=page_token,
                    )

                    items.extend(project_data_paged_list.items)

                    page_token = project_data_paged_list.next_page_token
                    if not project_data_paged_list.next_page_token:
                        break

            except ApiException as e:
                logger.error(e)

        return items

    def download(self, file_id):
        with closing(self.api_client) as ctx_api_client:
            project_data_api: ProjectDataApi = ProjectDataApi(api_client=ctx_api_client)
            dl: Download = project_data_api.create_download_url_for_data(
                project_id=self.project_id,
                data_id=file_id,
            )
            return dl

    def download_by_file_path(self, file_path: str) -&gt; (Download, None):
        logger.info(f&#34;Downloading file from project_id {self.project_id} at {file_path}&#34;)

        file_list = self.list_files(file_path=file_path)

        if not len(file_list) == 1:
            logger.warning(f&#34;Please specify a single file. &#34;
                           f&#34;Found {len(file_list)} files in project_id {self.project_id} at {file_path}&#34;)
            return None

        if len(file_list) == 0:
            logger.warning(f&#34;File not found in in project_id {self.project_id} at {file_path}&#34;)
            return None

        prj_data: ProjectData = file_list[0]

        return self.download(prj_data.data.id)

    def create_presigned_url(self, file_path: str) -&gt; str:
        return self.download_by_file_path(file_path).url

    def download_file(self, file_path: str) -&gt; (NamedTemporaryFile, None):
        &#34;&#34;&#34;Retrieve _single_ Project data file

        It collects matching path (one exact file) through list_files().
        Hence, there should only be one item in the list.
        Then, we use requests library to download the file from presigned URL to temporary storage.
        The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes &#39;out of scope&#39;.

        NOTE:
        If multiple files are found, it warns and return None.

        It is recommended to close NamedTemporaryFile after use.
        For example, work within closing context manager like so.
            with closing(ntf) as f:
                with open(f.name, newline=&#39;&#39;) as csv_file:
                    csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
                    ...
                    ...

        :param file_path: the GDS path of the file to download
        :return NamedTemporaryFile: or None if file is not found or multiple files are found
        &#34;&#34;&#34;
        presigned_url = self.create_presigned_url(file_path)

        req = requests.get(presigned_url)

        ntf = NamedTemporaryFile()
        with open(ntf.name, &#39;wb&#39;) as f:
            f.write(req.content)

        return ntf

    def presign_file(self, file_id: str) -&gt; (bool, str):
        try:
            dl = self.download(file_id)
            return True, dl.url
        except ApiException as e:
            message = f&#34;Failed to sign the specified file {file_id} in project {self.project_id}. Exception - {e}&#34;
            logger.error(message)
            return False, message</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="libica.app.dataops.ProjectDataOps.check_path"><code class="name flex">
<span>def <span class="ident">check_path</span></span>(<span>self, file_path: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Use cases
This behaves like UNIX <code>ls</code> command whereas you can check an absolute path to file or a directory.
You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
Otherwise, it returns file(s) found.</p>
<p>NOTE: This wrap list_files but more strict to raise FileNotFoundError if zero match.</p>
<p>:param file_path:
:return: List of ProjectData objects
:rtype: list[ProjectData]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_path(self, file_path: str) -&gt; list:
    &#34;&#34;&#34;Use cases
    This behaves like UNIX `ls` command whereas you can check an absolute path to file or a directory.
    You can use it to check whether a file exist in GDS because it raises FileNotFoundError.
    Otherwise, it returns file(s) found.

    NOTE: This wrap list_files but more strict to raise FileNotFoundError if zero match.

    :param file_path:
    :return: List of ProjectData objects
    :rtype: list[ProjectData]
    &#34;&#34;&#34;

    files = self.list_files(file_path)
    if len(files) == 0:
        raise FileNotFoundError(f&#34;No file(s) found in project {self.project_id} at {file_path}&#34;)
    return files</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.create_presigned_url"><code class="name flex">
<span>def <span class="ident">create_presigned_url</span></span>(<span>self, file_path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_presigned_url(self, file_path: str) -&gt; str:
    return self.download_by_file_path(file_path).url</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, file_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self, file_id):
    with closing(self.api_client) as ctx_api_client:
        project_data_api: ProjectDataApi = ProjectDataApi(api_client=ctx_api_client)
        dl: Download = project_data_api.create_download_url_for_data(
            project_id=self.project_id,
            data_id=file_id,
        )
        return dl</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.download_by_file_path"><code class="name flex">
<span>def <span class="ident">download_by_file_path</span></span>(<span>self, file_path: str) ‑> (<class '<a title="libica.openapi.v2.model.download.Download" href="../openapi/v2/model/download.html#libica.openapi.v2.model.download.Download">Download</a>'>, None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_by_file_path(self, file_path: str) -&gt; (Download, None):
    logger.info(f&#34;Downloading file from project_id {self.project_id} at {file_path}&#34;)

    file_list = self.list_files(file_path=file_path)

    if not len(file_list) == 1:
        logger.warning(f&#34;Please specify a single file. &#34;
                       f&#34;Found {len(file_list)} files in project_id {self.project_id} at {file_path}&#34;)
        return None

    if len(file_list) == 0:
        logger.warning(f&#34;File not found in in project_id {self.project_id} at {file_path}&#34;)
        return None

    prj_data: ProjectData = file_list[0]

    return self.download(prj_data.data.id)</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.download_file"><code class="name flex">
<span>def <span class="ident">download_file</span></span>(<span>self, file_path: str) ‑> (<function NamedTemporaryFile at 0x10e34e3a0>, None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve <em>single</em> Project data file</p>
<p>It collects matching path (one exact file) through list_files().
Hence, there should only be one item in the list.
Then, we use requests library to download the file from presigned URL to temporary storage.
The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes 'out of scope'.</p>
<p>NOTE:
If multiple files are found, it warns and return None.</p>
<p>It is recommended to close NamedTemporaryFile after use.
For example, work within closing context manager like so.
with closing(ntf) as f:
with open(f.name, newline='') as csv_file:
csv_reader = csv.reader(csv_file, delimiter=',')
&hellip;
&hellip;</p>
<p>:param file_path: the GDS path of the file to download
:return NamedTemporaryFile: or None if file is not found or multiple files are found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_file(self, file_path: str) -&gt; (NamedTemporaryFile, None):
    &#34;&#34;&#34;Retrieve _single_ Project data file

    It collects matching path (one exact file) through list_files().
    Hence, there should only be one item in the list.
    Then, we use requests library to download the file from presigned URL to temporary storage.
    The downloaded file is back by NamedTemporaryFile and, therefore will be deleted once it goes &#39;out of scope&#39;.

    NOTE:
    If multiple files are found, it warns and return None.

    It is recommended to close NamedTemporaryFile after use.
    For example, work within closing context manager like so.
        with closing(ntf) as f:
            with open(f.name, newline=&#39;&#39;) as csv_file:
                csv_reader = csv.reader(csv_file, delimiter=&#39;,&#39;)
                ...
                ...

    :param file_path: the GDS path of the file to download
    :return NamedTemporaryFile: or None if file is not found or multiple files are found
    &#34;&#34;&#34;
    presigned_url = self.create_presigned_url(file_path)

    req = requests.get(presigned_url)

    ntf = NamedTemporaryFile()
    with open(ntf.name, &#39;wb&#39;) as f:
        f.write(req.content)

    return ntf</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.get_file_to_bytes"><code class="name flex">
<span>def <span class="ident">get_file_to_bytes</span></span>(<span>self, file_path: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>get_object_to_bytes API, with on-the-fly gzip detection and decompression</p>
<p>:param file_path:
:return bytes: bytes from the decompressed File body</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_to_bytes(self, file_path: str) -&gt; bytes:
    &#34;&#34;&#34;
    get_object_to_bytes API, with on-the-fly gzip detection and decompression

    :param file_path:
    :return bytes: bytes from the decompressed File body
    &#34;&#34;&#34;
    try:
        ntf = self.download_file(file_path)
        if file_path.endswith(&#34;.gz&#34;):
            obj_bytes = gzip.decompress(ntf.read())
        else:
            obj_bytes = ntf.read()
        ntf.close()
        return obj_bytes
    except Exception as e:
        message = f&#34;Failed on reading the specified file in project {self.project_id} at {file_path}&#34;
        raise FileNotFoundError(f&#34;{message} Exception: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.list_files"><code class="name flex">
<span>def <span class="ident">list_files</span></span>(<span>self, file_path=None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Use cases
Get file listing for given project_id and paths.
If path are not specified, it will return listing of all files under given project_id.
Listing is recursive in nature for folder path.
You can still specify an absolute path for a file.</p>
<p>:param file_path: default list all
:return: List of ProjectData objects
:rtype: list[ProjectData]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_files(self, file_path=None) -&gt; list:
    &#34;&#34;&#34;Use cases
    Get file listing for given project_id and paths.
    If path are not specified, it will return listing of all files under given project_id.
    Listing is recursive in nature for folder path.
    You can still specify an absolute path for a file.

    :param file_path: default list all
    :return: List of ProjectData objects
    :rtype: list[ProjectData]
    &#34;&#34;&#34;

    if file_path is None:
        file_path = []  # list everything
    elif isinstance(file_path, str):
        file_path = [file_path]  # wrap str into list

    items = []

    with closing(self.api_client) as ctx_api_client:
        project_data_api: ProjectDataApi = ProjectDataApi(api_client=ctx_api_client)

        try:
            page_token = &#34;&#34;
            while True:
                project_data_paged_list: ProjectDataPagedList = project_data_api.get_project_data_list(
                    project_id=self.project_id,
                    file_path=file_path,
                    page_size=str(1000),
                    page_token=page_token,
                )

                items.extend(project_data_paged_list.items)

                page_token = project_data_paged_list.next_page_token
                if not project_data_paged_list.next_page_token:
                    break

        except ApiException as e:
            logger.error(e)

    return items</code></pre>
</details>
</dd>
<dt id="libica.app.dataops.ProjectDataOps.presign_file"><code class="name flex">
<span>def <span class="ident">presign_file</span></span>(<span>self, file_id: str) ‑> (<class 'bool'>, <class 'str'>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def presign_file(self, file_id: str) -&gt; (bool, str):
    try:
        dl = self.download(file_id)
        return True, dl.url
    except ApiException as e:
        message = f&#34;Failed to sign the specified file {file_id} in project {self.project_id}. Exception - {e}&#34;
        logger.error(message)
        return False, message</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="libica.app" href="index.html">libica.app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="libica.app.dataops.BundleDataOps" href="#libica.app.dataops.BundleDataOps">BundleDataOps</a></code></h4>
</li>
<li>
<h4><code><a title="libica.app.dataops.ProjectDataOps" href="#libica.app.dataops.ProjectDataOps">ProjectDataOps</a></code></h4>
<ul class="">
<li><code><a title="libica.app.dataops.ProjectDataOps.check_path" href="#libica.app.dataops.ProjectDataOps.check_path">check_path</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.create_presigned_url" href="#libica.app.dataops.ProjectDataOps.create_presigned_url">create_presigned_url</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.download" href="#libica.app.dataops.ProjectDataOps.download">download</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.download_by_file_path" href="#libica.app.dataops.ProjectDataOps.download_by_file_path">download_by_file_path</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.download_file" href="#libica.app.dataops.ProjectDataOps.download_file">download_file</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.get_file_to_bytes" href="#libica.app.dataops.ProjectDataOps.get_file_to_bytes">get_file_to_bytes</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.list_files" href="#libica.app.dataops.ProjectDataOps.list_files">list_files</a></code></li>
<li><code><a title="libica.app.dataops.ProjectDataOps.presign_file" href="#libica.app.dataops.ProjectDataOps.presign_file">presign_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>